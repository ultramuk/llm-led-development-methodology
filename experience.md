# 경험 문서: LLM주도 개발 방법론

## 1. 해결한 문제

프로덕션 레벨의 웹 개발 프로젝트를 진행하면서 겪었던 가장 큰 문제는 **LLM의 결과를 예측할 수 없다는 것**이었다.

10만 줄이 넘어가는 규모의 프로젝트에서 LLM과 함께 작업하다 보니, 처음에는 내가 원하는 것을 잘 개발하다가 어느 정도 규모가 커지면 갑자기 전혀 다른 것을 개발하기 시작하는 패턴을 발견했다. 이것이 바로 맥락이 점점 희미해지면서 원래 방향을 잃어버리는 문제였다.

구체적인 예시를 들면, 로그인 기능을 만들어달라고 요청했는데 갑자기 혼자 오버 엔지니어링해서 어드민 페이지를 만들어버리는 일이 자주 발생했다. 더 심각한 문제는 프로젝트 컨벤션을 완전히 무시하는 것이었다. React Router를 사용해서 서버사이드로 동작하는 환경에서 API 라우터 대신 로더와 액션을 사용해야 하는데, LLM이 이런 프로젝트 규칙을 무시하고 API 라우터로 개발해서 코드가 아예 동작하지 않는 상황이 반복됐다.

**가장 충격적이었던 경험은 1달간 작업한 코드베이스를 통째로 롤백해야 했던 것**이다. 꼬여버린 구조 속에서 더 이상 개발을 진행할 수 없었고, 설상가상으로 LLM이 그 엉망이 된 코드를 참조로 삼아 더욱 이해할 수 없는 방향으로 발전시키는 악순환이 계속됐다. 프로젝트를 몇 번이나 처음부터 다시 시작해야 했는지 모를 정도였다.

이 문제가 특히 치명적인 이유는, 프로덕션 레벨 사이트 개발에서는 매우 디테일하고 정확한 요구사항을 바탕으로 작업해야 하며, 소스 코드 품질 유지를 위한 검증 도구와 테스트까지 활용하고 있기 때문이다. 이런 고도화된 개발 환경에서 LLM의 예측 불가능성은 제품 개발 자체를 불가능하게 만드는 근본적인 장벽이었다.

## 2. 해결 과정

### 초기 대응

문제 상황을 정확히 파악하는 것부터 시작했다. LLM이 처음에는 요구사항을 정확히 이해하고 잘 개발하다가, 프로젝트 규모가 커질수록 점차 다른 방향으로 빠지는 명확한 패턴이 있었다. 이것이 바로 처음 설정한 맥락을 점점 잊어가면서 엉뚱한 방향으로 흘러가는 문제라는 걸 깨달았다. 잘하다가 어느 순간부터 LLM이 완전히 다른 결과를 내기 시작하는 것이었다.

**첫 번째 시도는 더 상세하고 정확한 지시사항을 작성하는 것**이었다. 매번 맥락을 재입력하고, 작업 내용을 일일이 모두 명시해주려고 했다. 하지만 이 방법은 근본적인 한계가 있었다. 입력하는 소스의 품질이 들쭉날쭉하니 LLM의 결과도 들쭉날쭉했고, 특히 중간에 맥락이 손실되면 아예 다른 결과가 나오는 일이 빈번했다. 이는 단순한 임시방편에 불과했다.

### 본격적인 접근 방식 전환

1달간의 작업을 롤백하는 절망적인 경험을 겪은 후, **근본적인 관점 전환**이 일어났다. "LLM 자체의 문제가 아니라 사용 방법의 문제"라는 인식으로 바뀐 것이다.

이 깨달음을 바탕으로, LLM과 함께 개발하려면 명확한 기준과 체계가 반드시 필요하다고 판단했다. 그래서 **기존에 사람과 함께 해오던 개발 프로세스를 LLM에 적용**할 수 있는 방법을 모색하기 시작했다.

여기서 핵심 아이디어가 등장했다: **LLM을 매우 능력 있지만 "척하면 척이 안 되는" 주니어 엔지니어로 생각하기 시작한 것**이었다. 아무리 LLM이 개발 능력이 뛰어나다 해도, LLM만으로 프로덕트를 완성하는 사례가 아직 없는 이유를 이해하게 됐다.

### 체계적인 해결책 구현

가장 우선적으로 도입한 것은 **명확한 역할과 책임(R&R) 설정**이었다. 사람-LLM-기계 각각의 역할과 책임을 분명히 구분해서, 서로의 영역을 침범하지 않으면서도 최적의 협업 결과를 낼 수 있는 체계를 구축했다.

다음으로 해결해야 할 핵심 과제는 **맥락 관리**였다. LLM의 메모리 한계를 인정하고, 모든 정보를 매번 입력하는 대신 중복되고 반복적으로 사용되는 내용을 효과적으로 문서화하는 시스템을 만들었다.

**레퍼런스 별도 관리 시스템**을 구축한 결과, 나는 별도 입력 없이도 LLM이 일관된 기준을 자동으로 참조할 수 있게 됐다. 이전보다 훨씬 더 일관성 있는 결과를 얻을 수 있게 됐고, 무엇보다 중요한 것은 **매번 검증하고 피드백을 주지 않아도 어느 정도 규모의 작업을 한 번에 처리**할 수 있게 됐다는 점이다.

물론 최종 검증은 여전히 필요하지만, 사람의 개입이 대폭 줄어든 것은 매우 고무적인 결과였다. 이제는 **기능 단위의 작업을 LLM이 독립적으로 수행**할 수 있게 됐다. 예를 들어 로그인 기능 개발이나 C++의 클래스 하나 정도는 안정적으로 완성할 수 있는 수준에 도달했다.

## 3. 핵심 원리

1. **R&R을 명확하게 하라**
2. **일관성을 창의성보다 우선하라**
3. **꼭 필요한 것만 하게 하라**
4. **명시적으로 컨텍스트 관리를 하라**
5. **구조를 통해 역할을 명확하게 하라**
6. **추상화를 통해 책임영역을 명확하게 하라**
7. **왜(Why)와 무엇(What)만 정의하고 어떻게(How)는 위임하라**
8. **작업과정을 명시적으로 진행하라**
9. **점진적으로 작업하고 롤백 가능하게 하라**
10. **반드시 검증하라**
11. **전문 영역은 에이전트에게 위임하라**
12. **반복적인 작업은 커맨드를 만들어서 관리하라**

## 4. 실습 과제

1. 시스템 정의
2. 컨텍스트 관리 시스템 구축
3. 명령어 시스템 구축
4. 에이전트 시스템 구축
5. 전역 시스템 프롬프트 구축
6. 프로젝트 시스템 프롬프트 구축
7. 개발 프로세스 정의
8. 프로젝트 도메인 기반 문서 작성

## 5. 결과물과 가치

### 최종 결과물: .claude 시스템

내가 만든 최종 결과물은 **`.claude` 시스템**이다. 이는 단순한 폴더 구조가 아니라, LLM과의 협업을 체계화한 완전한 개발 방법론이다.

#### 시스템 구성

- **CLAUDE.md**: 12가지 핵심 원리를 담은 루트 시스템 프롬프트
- **agents/**: 25개 이상의 도메인별 전문 에이전트
- **commands/**: 반복 작업 자동화 명령어
- **documents/**: 프로젝트 컨텍스트 관리 문서

#### 핵심 혁신: 3-Tier 아키텍처

```bash
Human (요구사항 정의) → LLM Operator (작업 분석) → Tools & Agents (실행)
```

이 구조를 통해 LLM이 단순 도구가 아닌 **지능적인 작업 관리자(Operator)**로 동작하게 만들었다.

### 실제 성과

#### Before (시스템 도입 전)

- 1달간 작업한 코드를 통째로 롤백
- React Router 컨벤션 무시로 동작하지 않는 코드 양산
- 오버엔지니어링으로 불필요한 기능 추가
- 10만 줄 프로젝트에서 방향성 상실

#### After (시스템 도입 후)

- **기능 단위로 안정적인 개발**: 롤백 없이 점진적 진행
- **프로젝트 규칙 100% 준수**: 로더/액션 패턴 일관성 유지
- **요구사항 범위 내 정확한 작업**: 오버엔지니어링 제거
- **대규모 프로젝트에서도 일관성 유지**: 컨텍스트 보존

### 가치와 의미

이 시스템의 진정한 가치는 **"LLM을 예측 가능한 개발 파트너로 만들었다"**는 점이다. 더 이상 LLM이 무엇을 만들어낼지 불안해하지 않아도 된다.

특히 프로덕션 레벨 개발에서 요구되는 높은 수준의 일관성과 품질을 유지하면서도, LLM의 생산성 이점을 최대한 활용할 수 있게 됐다. 이제 나는 "왜"와 "무엇"에만 집중하고, "어떻게"는 시스템이 알아서 처리한다.
