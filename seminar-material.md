# LLM주도 개발 방법론 세미나

## "LLM이 멋대로 날뛰는 걸 잡는 방법"

**대상:** LLM 개발 경험이 있지만 일관성 문제를 겪는 개발자  
**목표:** 프로덕션 레벨에서 LLM을 예측 가능한 파트너로 만드는 방법

---

## 1. 도입: 절망적인 경험담

### 스토리: 1달간의 작업이 사라진 날

> "10만 줄짜리 프로덕션 웹 프로젝트를 LLM과 함께 개발하고 있었습니다.  
> 처음에는 정말 잘했어요. 로그인 기능, 사용자 관리, API 구현... 모든 게 순조로웠죠.  
> 그런데 프로젝트가 커질수록 뭔가 이상해지기 시작했습니다."

**실제 문제들:**

- 로그인 기능 요청 → LLM이 혼자 어드민 페이지까지 만들어버림
- React Router 환경인데 API 라우터로 개발해서 아예 동작 안 함
- 프로젝트 컨벤션 완전 무시
- 매번 다른 패턴으로 개발해서 일관성 제로

**절망의 순간:**
> "결국 1달간 작업한 코드베이스를 통째로 롤백했습니다.  
> 꼬여버린 구조 속에서 더 이상 개발을 진행할 수 없었거든요.  
> LLM이 그 엉망이 된 코드를 참조로 삼아 더욱 이상한 방향으로 발전시키는 악순환..."

**핵심 깨달음:**

- 문제는 LLM이 아니라 **사용 방법**이었다
- LLM은 매우 능력 있지만 **"척하면 척이 안 되는" 주니어 엔지니어**
- **명확한 기준과 체계**가 없으면 예측할 수 없는 결과만 나온다

---

## 2. 문제 분석: 왜 LLM이 멋대로 날뛰는가?

### 근본적 문제들

**1. 역할과 책임이 애매함**

- 사람: "알아서 잘 해줘"
- LLM: "내가 다 해야겠구나" → 설계부터 구현까지 오버엔지니어링

**2. 맥락 손실**

- 대화가 길어지면 처음 설정한 규칙을 까먹음
- 새로운 세션에서는 완전히 다른 방식으로 접근
- 프로젝트 컨벤션? 그게 뭐죠?

**3. 창의성이라는 이름의 혼란**

- "더 좋은 방법이 있어요!" → 프로젝트 망가뜨리기
- 매번 다른 패턴 적용 → 일관성 파괴
- 보안, 스케일링 등 불필요한 기능 추가 → 8시간 작업이 6개월 프로젝트로

**4. 검증 부재**

- LLM 결과물을 그대로 신뢰
- 사람이 코드 한 줄씩 검토 → 비효율의 극치
- 문제 발견이 늦어져서 롤백 지점 놓침

### 결과: 예측 불가능한 LLM

**Before 상황:**

```
요청: "로그인 기능 만들어줘"
결과: ❌ 어드민 페이지 + OAuth + 2FA + 보안 모니터링 + ...
```

**우리가 원하는 것:**

```
요청: "로그인 기능 만들어줘" 
결과: ✅ 정확히 로그인 기능. 프로젝트 컨벤션 준수. 동작함.
```

---

## 3. 솔루션 개요: 체계적인 LLM 관리

### 핵심 아이디어: 3-Tier 아키텍처

```
Human (요구사항 정의)
  ↓ What, Why
LLM Operator (작업 분석 및 위임)  
  ↓ How
Tools & Agents (실행)
```

**각자의 역할:**

- **Human**: 설계, 방향성, 최종 검토
- **LLM**: 구현, 코드 작성, 구조적 작업  
- **Tools**: 품질 검증, 자동화, 무결성 보장

### 12가지 ROOT 원리 (핵심만)

**1. R&R을 명확하게 하라**

- 누가 뭘 하는지 확실하게 정하기
- 사람은 설계, LLM은 구현, 도구는 검증

**2. 일관성을 창의성보다 우선하라**  

- LLM의 창의성 = 혼란
- 검증된 패턴만 사용하게 제한

**3. 꼭 필요한 것만 하게 하라**

- 8시간 작업을 6개월 프로젝트로 만드는 발산 방지
- "보안", "확장성" 언급하면 즉시 중단

**4. 명시적으로 컨텍스트 관리를 하라**

- LLM 기억력 한계 인정
- 문서 시스템으로 맥락 보존

**5. 반드시 검증하라**

- LLM 코드의 80%는 쓰레기
- 자동화 도구로 검증, 사람은 개념만

### 실제 시스템 구조

```
fruit/
├── system-prompt.md           # LLM의 기본 행동 규칙
├── agents/                    # 도메인별 전문가들
│   ├── backend/               # 백엔드 전문가
│   ├── frontend/              # 프론트엔드 전문가
│   └── quality/               # 품질 관리 전문가
├── commands/                  # 자동화 명령어들
│   ├── implement/             # 구현 관련
│   ├── review/               # 리뷰 관련
│   └── deploy/               # 배포 관련
└── documents/                 # 문서 관리 시스템
    ├── templates/             # 문서 템플릿
    ├── guidelines/            # 개발 가이드라인
    ├── architectures/         # 기술 아키텍처
    ├── design/                # 디자인 문서
    └── discussions/           # 대화 기록
```

---

## 4. 핵심 구성요소 상세

### 4.1 System Prompt: LLM의 헌법

**구조:**

```markdown
# Role
- Responsibilities: 뭘 해야 하는가
- Authority: 어디까지 권한이 있는가  
- Position: 전체 구조에서의 위치

# Principles  
- Understanding: 이해 원칙
- Execution: 실행 원칙
- Quality: 품질 원칙
- Management: 관리 원칙

# Structure
- documents 폴더 구조
- 참조 방법
```

**실제 예시:**

```markdown
## Principles

### Execution
3. **Consistency Over Creativity**: 검증된 패턴만 사용하고 창의적 해결책 제안 금지
4. **Minimal Change**: 꼭 필요한 변경만 수행, 추가 기능 제안 금지
5. **Readability First**: 영리한 코드보다 읽기 쉬운 코드 우선
```

### 4.2 Agents: 도메인별 전문가 시스템

**에이전트 구조:**

```markdown
# Role
이 에이전트의 역할 한 줄 요약

# Expertise  
- 전문 지식 영역
- 사용 가능한 도구/기술

# Personality
- 일하는 스타일
- 소통 방식

# Boundaries
## What I Do
- 담당 업무 범위

## What I Don't Do  
- 절대 하지 않는 일들
```

**예시: backend-engineer.md**

```markdown
# Role
서버 사이드 로직과 API 구현을 전담하는 백엔드 전문가

# Boundaries
## What I Don't Do
- 프론트엔드 관련 작업은 frontend-engineer에게 위임
- 데이터베이스 스키마 설계는 database-engineer에게 위임
- 보안 설계는 security-architect에게 위임
```

### 4.3 Commands: 반복 작업 자동화

**커맨드 구조:**

```markdown
# 커맨드명
설명

## 입력
필요한 정보들

## 과정  
단계별 진행 과정

## 출력
결과물

## 검증
품질 확인 방법
```

**예시: implement.md**

```markdown
# 기능 구현

## 과정
1. 요구사항 분석 및 범위 확정
2. 기존 코드 패턴 확인
3. 최소한의 변경으로 구현
4. 린터/테스트 통과 확인
5. 코드 리뷰 준비
```

---

## 5. 실제 효과: Before/After

### Before: 시스템 도입 전

**문제 상황들:**

```javascript
// 요청: "사용자 목록 API 만들어줘"
// LLM 결과: 🤯

// 1. 오버엔지니어링
app.get('/users', authenticate, authorize, validateRequest, 
  rateLimit, cacheCheck, auditLog, async (req, res) => {
  // pagination, sorting, filtering, search, export 다 들어감
  // 요청한 건 그냥 목록인데...
});

// 2. 컨벤션 무시  
// 프로젝트는 TypeScript + Express인데
import { createServer } from 'http'; // 갑자기 순수 Node.js
const server = createServer(); // 뭔가 완전 다른 구조
```

**결과:**

- 1달간 작업 → 전체 롤백
- 프로젝트 진행 불가
- LLM에 대한 신뢰 완전 상실

### After: 시스템 도입 후

**동일한 요청의 결과:**

```javascript
// 요청: "사용자 목록 API 만들어줘"
// LLM 결과: ✅

// 1. 정확한 범위
app.get('/api/users', async (req: Request, res: Response) => {
  const users = await User.findAll();
  res.json(users);
});

// 2. 프로젝트 컨벤션 준수
// - TypeScript 타입 정의 ✅
// - 기존 라우터 패턴 따름 ✅  
// - 에러 핸들링 패턴 동일 ✅
// - 코딩 스타일 일관성 ✅
```

**핵심 차이점:**

| 구분 | Before | After |
|-----|--------|-------|
| 일관성 | 매번 다른 패턴 | 프로젝트 컨벤션 100% 준수 |
| 범위 | 요청의 5배 구현 | 요청한 것만 정확히 |
| 품질 | 동작 안 하는 코드 | 린터/테스트 통과 |
| 예측성 | 뭘 만들지 모름 | 결과를 미리 알 수 있음 |
| 개발 속도 | 롤백으로 -100% | 기능 단위로 안정적 진행 |

### 실제 성과 지표

**정량적 효과:**

- 롤백 횟수: 월 3-4회 → 0회
- 코드 리뷰 시간: 기능당 2시간 → 20분  
- 프로젝트 진행률: 예측 불가 → 계획 대비 95% 달성
- LLM 생산성: 불신으로 사용 중단 → 핵심 개발 파트너

**정성적 효과:**

- LLM에 대한 신뢰 회복
- 개발 프로세스 예측 가능
- 팀 전체 LLM 도입 가능
- 프로덕션 레벨 품질 달성

---

## 6. 적용 방법: 실전 가이드

### 6.1 시작하기

**1단계: 문제 인식**

- 현재 LLM 사용에서 겪고 있는 문제 정리
- 롤백 경험, 일관성 문제, 예측 불가능성 체크

**2단계: 기본 시스템 프롬프트 작성**

```markdown
# fruit/system-prompt.md 참고하여 작성
# 최소한 Role, Principles, Structure 3개 섹션 포함
# 자신의 프로젝트 특성에 맞게 커스터마이징
```

**3단계: 첫 번째 테스트**

- 기존에 문제가 있었던 작업을 시스템 프롬프트와 함께 재시도
- Before/After 차이 확인

### 6.2 시스템 구축

**문서 구조 생성:**

```bash
mkdir -p documents/{templates,guidelines,architectures,design,discussions}
```

**첫 번째 에이전트 생성:**

- 가장 자주 사용하는 도메인 (백엔드, 프론트엔드 등)
- fruit/agents/ 폴더의 템플릿 참고

**첫 번째 커맨드 생성:**

- 가장 반복적인 작업 (구현, 리뷰, 배포 등)
- fruit/commands/ 폴더의 템플릿 참고

### 6.3 점진적 개선

**주간 체크포인트:**

- [ ] 이번 주 롤백이 발생했는가?
- [ ] LLM 결과물이 예상과 다른 적이 있는가?
- [ ] 새로운 반복 작업이 발견되었는가?
- [ ] 시스템 프롬프트 업데이트가 필요한가?

**월간 개선:**

- 새로운 에이전트 추가
- 커맨드 최적화
- 팀 공유 및 표준화

### 6.4 도메인별 커스터마이징

**웹 개발팀:**

- agents: frontend-engineer, backend-engineer, database-designer
- commands: create-component, setup-api, deploy-full-stack

**데이터팀:**

- agents: data-analyst, ml-engineer, visualization-expert
- commands: clean-data, train-model, generate-report

**DevOps팀:**

- agents: infrastructure-architect, deployment-specialist
- commands: deploy-app, rollback, scale-service

---

## 7. 라이브 데모 시나리오

### 데모 준비사항

- 실제 LLM 도구 (Claude, ChatGPT 등)
- fruit 시스템이 적용된 샘플 프로젝트
- Before/After 비교할 수 있는 동일한 작업

### 데모 스크립트

**1단계: Before 시연 (5분)**

```
시연: "사용자 인증 API 만들어줘"
→ LLM이 오버엔지니어링하는 모습 실시간 시연
→ 불필요한 기능들이 추가되는 과정 보여주기
→ 프로젝트 컨벤션 무시하는 모습
```

**2단계: 시스템 적용 (5분)**

```
시연: 동일한 작업에 system-prompt 적용
→ 시스템 프롬프트 로딩하는 과정
→ 에이전트 호출하는 방법  
→ 커맨드 사용하는 방법
```

**3단계: After 결과 (5분)**

```
시연: 개선된 결과물 확인
→ 정확한 범위로 구현된 코드
→ 프로젝트 컨벤션 준수
→ 린터/테스트 통과하는 모습
```

**4단계: 실시간 커스터마이징 (5분)**

```
시연: 참가자 요청사항으로 즉석 개선
→ 새로운 에이전트 생성하기
→ 커맨드 수정하기
→ 시스템 프롬프트 조정하기
```

### 데모 포인트

- **실제 문제 재현**: 참가자들이 겪었을 법한 상황
- **즉각적인 개선 효과**: 시스템 적용 전후 명확한 차이
- **실용성 강조**: 당장 오늘부터 쓸 수 있다는 점
- **커스터마이징 용이성**: 각자 환경에 맞게 조정 가능

---

## 8. 마무리 및 Next Steps (10분)

### 핵심 메시지

> **"LLM은 문제가 아니다. 사용 방법이 문제다."**

**오늘 배운 것:**

1. LLM의 예측 불가능성은 해결 가능한 문제
2. 체계적인 시스템으로 일관된 결과 확보 가능
3. 프로덕션 레벨에서도 LLM을 신뢰할 수 있음
4. 설정에 투자한 시간은 수십 배로 회수됨

### 실행 가이드

**오늘 바로 해볼 것:**

1. seeds/003 폴더의 모든 문서 읽어보기
2. 현재 사용 중인 LLM에 기본 시스템 프롬프트 적용
3. 가장 문제가 되는 작업 하나로 테스트

**이번 주 안에 할 것:**

1. 자신의 도메인에 맞는 첫 번째 에이전트 생성
2. 가장 반복적인 작업을 커맨드로 만들기  
3. Before/After 결과 문서화

**한 달 안에 달성할 것:**

1. 완전한 개인 맞춤형 LLM 시스템 구축
2. 팀 표준으로 확산
3. 롤백 제로 달성

### 연락처 및 리소스

**참고 자료:**

- 전체 문서: `/seeds/003/` 폴더
- 실습 가이드: `overview.md`  
- 완성 예시: `fruit/` 폴더
- 핵심 원리: `roots/` 폴더
- 단계별 학습: `branches/` 폴더

**질문 및 지원:**

- 구현 중 막히는 부분 언제든 연락
- 팀 도입 컨설팅 가능
- 정기 업데이트 공유

---

## Q&A 예상 질문 및 답변

**Q: 시스템 구축에 얼마나 시간이 걸리나요?**
A: 기본 시스템 프롬프트는 30분, 첫 번째 에이전트는 1시간 정도입니다. 하지만 이 투자로 앞으로 수백 시간을 절약할 수 있어요.

**Q: 다른 LLM 도구(ChatGPT, Cursor 등)에도 적용 가능한가요?**  
A: 네, 플랫폼 독립적으로 설계되었습니다. 각 도구의 특성에 맞게 약간의 조정만 하면 됩니다.

**Q: 팀 전체에 도입하려면 어떻게 해야 하나요?**
A: 먼저 한 사람이 완전히 구축한 후, 팀 표준 템플릿을 만들어 배포하는 것을 추천합니다. 개인차를 고려한 커스터마이징도 허용해야 해요.

**Q: 기존 프로젝트에 중간에 적용해도 되나요?**
A: 물론입니다. 오히려 문제가 많은 프로젝트일수록 효과가 확실해요. 점진적으로 적용하면 리스크도 최소화할 수 있습니다.

**Q: 이 방법론으로 완전히 자동화된 개발이 가능한가요?**  
A: 아니요, 그게 목표가 아닙니다. Human-LLM-Tools의 협업에서 각자 최고의 역할을 하는 게 목표예요. 사람은 여전히 설계와 검토를 담당해야 합니다.
